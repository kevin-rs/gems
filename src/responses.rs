use crate::requests::Candidate as ReqCandidate;
use serde::{Deserialize, Serialize};

/// Response structure for content embedding.
#[derive(Debug, Deserialize)]
pub struct EmbedContentResponse {
    /// The embedding information.
    pub embedding: Option<Embedding>,
}

/// Response structure for batch content embedding.
#[derive(Debug, Deserialize)]
pub struct BatchEmbedContentsResponse {
    /// The list of embeddings for batched contents.
    pub embeddings: Option<Vec<Embedding>>,
}

/// Structure representing embedding information.
#[derive(Debug, Deserialize, Default, Clone)]
pub struct Embedding {
    /// List of values for the embedding.
    pub values: Vec<f64>,
}

/// Structure representing information about a model.
#[derive(Debug, Serialize, Deserialize)]
pub struct ModelInfo {
    /// The name of the model.
    pub name: String,

    /// The version of the model.
    pub version: String,

    /// The display name of the model.
    #[serde(rename = "displayName")]
    pub display_name: String,

    /// The description of the model (optional in some cases).
    pub description: Option<String>,

    /// The limit on input tokens accepted by the model.
    #[serde(rename = "inputTokenLimit")]
    pub input_token_limit: i32,

    /// The limit on output tokens generated by the model.
    #[serde(rename = "outputTokenLimit")]
    pub output_token_limit: i32,

    /// The list of supported generation methods for the model.
    #[serde(rename = "supportedGenerationMethods")]
    pub supported_generation_methods: Vec<String>,

    /// The temperature parameter for controlling randomness in generation.
    pub temperature: Option<f32>,

    /// The max temperature allowed for the model (optional).
    #[serde(rename = "maxTemperature")]
    pub max_temperature: Option<f32>,

    /// The top-P parameter for nucleus sampling in generation (optional).
    #[serde(rename = "topP")]
    pub top_p: Option<f32>,

    /// The top-K parameter for top-k sampling in generation (optional).
    #[serde(rename = "topK")]
    pub top_k: Option<i32>,
}

impl ModelInfo {
    /// Prints the model information in a formatted way.
    pub fn print(&self) {
        println!(
            r#"
Model:
    Name: {}
    Version: {}
    Display Name: {}
    Description: {}
    Input Token Limit: {}
    Output Token Limit: {}
    Supported Generation Methods: {:?}
    Temperature: {:?}
    Max Temperature: {:?}
    Top P: {:?}
    Top K: {:?}
"#,
            self.name.replace("models/", ""),
            self.version,
            self.display_name,
            self.description
                .clone()
                .unwrap_or_else(|| "N/A".to_string()),
            self.input_token_limit,
            self.output_token_limit,
            self.supported_generation_methods,
            self.temperature,
            self.max_temperature,
            self.top_p,
            self.top_k
        );
    }
}

/// Response structure for retrieving a list of models.
#[derive(Debug, Serialize, Deserialize)]
pub struct ModelsResponse {
    /// The list of models.
    pub models: Vec<ModelInfo>,
}

impl ModelsResponse {
    /// Prints information for each model in the list.
    pub fn print(&self) {
        for model in &self.models {
            model.print();
        }
    }
}
/// Response structure for content generation.
#[derive(Debug, Deserialize)]
pub struct GeminiResponse {
    /// List of generated candidates.
    pub candidates: Option<Vec<ReqCandidate>>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ImagenResponse {
    pub candidates: Option<Vec<Candidate>>,
    pub usage_metadata: Option<UsageMetadata>,
    pub model_version: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TtsCandidate {
    pub content: Content,
    pub finish_reason: Option<String>,
    pub index: Option<i32>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Content {
    pub parts: Vec<Part>,
    pub role: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum Part {
    Text {
        text: String,
    },
    Image {
        #[serde(rename = "inlineData")]
        inline_data: ImageContent,
    },
    Media {
        #[serde(rename = "inlineData")]
        inline_data: InlineData,
    },
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ImageContent {
    pub mime_type: String,
    pub data: String,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UsageMetadata {
    pub prompt_token_count: Option<i32>,
    pub total_token_count: Option<i32>,
    pub prompt_tokens_details: Option<Vec<PromptTokenDetail>>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PromptTokenDetail {
    pub modality: Option<String>,
    pub token_count: Option<i32>,
}

/// Response returned immediately after submitting the generation request.
#[derive(Debug, Deserialize)]
pub struct VideoGenResponse {
    pub name: Option<String>,
}

/// Polling response to check operation status.
#[derive(Debug, Deserialize)]
pub struct OperationStatus {
    pub done: Option<bool>,
    pub error: Option<OperationError>,
    pub response: Option<OperationResponse>,
}

/// Error details if the operation fails.
#[derive(Debug, Deserialize)]
pub struct OperationError {
    pub message: String,
}

/// Successful operation result.
#[derive(Debug, Deserialize)]
pub struct OperationResponse {
    pub output: VideoOutput,
}

/// Output payload containing the video.
#[derive(Debug, Deserialize)]
pub struct VideoOutput {
    pub video: EncodedVideo,
}

/// The actual video content encoded in base64.
#[derive(Debug, Deserialize)]
pub struct EncodedVideo {
    #[serde(rename = "mimeType")]
    pub mime_type: String,

    #[serde(rename = "base64Data")]
    pub base64_data: String,
}

#[derive(Debug, Deserialize)]
pub struct ErrorWrapper {
    pub error: ErrorMessage,
}

#[derive(Debug, Deserialize)]
pub struct ErrorMessage {
    pub message: String,
}

#[derive(Debug, Deserialize)]
pub struct TtsResponse {
    pub candidates: Option<Vec<Candidate>>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Candidate {
    pub content: Content,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct InlineData {
    pub mime_type: String,
    pub data: String,
}
