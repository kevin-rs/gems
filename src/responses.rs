use crate::requests::Candidate;
use serde::{Deserialize, Serialize};

/// Response structure for content embedding.
#[derive(Debug, Deserialize)]
pub struct EmbedContentResponse {
    /// The embedding information.
    pub embedding: Option<Embedding>,
}

/// Response structure for batch content embedding.
#[derive(Debug, Deserialize)]
pub struct BatchEmbedContentsResponse {
    /// The list of embeddings for batched contents.
    pub embeddings: Option<Vec<Embedding>>,
}

/// Structure representing embedding information.
#[derive(Debug, Deserialize)]
pub struct Embedding {
    /// List of values for the embedding.
    pub values: Vec<f64>,
}

/// Structure representing information about a model.
#[derive(Debug, Serialize, Deserialize)]
pub struct ModelInfo {
    /// The name of the model.
    pub name: String,

    /// The version of the model.
    pub version: String,

    /// The display name of the model.
    #[serde(rename = "displayName")]
    pub display_name: String,

    /// The description of the model.
    pub description: String,

    /// The limit on input tokens accepted by the model.
    #[serde(rename = "inputTokenLimit")]
    pub input_token_limit: i32,

    /// The limit on output tokens generated by the model.
    #[serde(rename = "outputTokenLimit")]
    pub output_token_limit: i32,

    /// The list of supported generation methods for the model.
    #[serde(rename = "supportedGenerationMethods")]
    pub supported_generation_methods: Vec<String>,

    /// The temperature parameter for controlling randomness in generation.
    pub temperature: Option<f32>,

    /// The top-P parameter for nucleus sampling in generation.
    #[serde(rename = "topP")]
    pub top_p: Option<f32>,

    /// The top-K parameter for top-k sampling in generation.
    #[serde(rename = "topK")]
    pub top_k: Option<i32>,
}

impl ModelInfo {
    /// Prints the model information in a formatted way.
    pub fn print(&self) {
        println!(
            r#"
Model:
    Name: {}
    Version: {}
    Display Name: {}
    Description: {}
    Input Token Limit: {}
    Output Token Limit: {}
    Supported Generation Methods: {:?}
    Temperature: {:?}
    Top P: {:?}
    Top K: {:?}
"#,
            self.name.replace("models/", ""),
            self.version,
            self.display_name,
            self.description,
            self.input_token_limit,
            self.output_token_limit,
            self.supported_generation_methods,
            self.temperature,
            self.top_p,
            self.top_k
        );
    }
}
/// Response structure for retrieving a list of models.
#[derive(Debug, Serialize, Deserialize)]
pub struct ModelsResponse {
    /// List of models.
    pub models: Vec<ModelInfo>,
}

impl ModelsResponse {
    /// Prints information for each model in the list.
    pub fn print(&self) {
        for model in &self.models {
            model.print();
        }
    }
}
/// Response structure for content generation.
#[derive(Debug, Deserialize)]
pub struct GeminiResponse {
    /// List of generated candidates.
    pub candidates: Option<Vec<Candidate>>,
}
